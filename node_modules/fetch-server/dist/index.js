"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_stream_1 = require("node:stream");
function createFetchServer(handler) {
    return (req, res) => {
        const method = req.method || 'GET';
        const headers = new Headers();
        for (const [key, value] of Object.entries(req.headers)) {
            if (Array.isArray(value)) {
                for (const v of value) {
                    headers.append(key, v);
                }
            }
            else if (typeof value === 'string') {
                headers.set(key, value);
            }
        }
        // TODO: determine `https`
        const proto = headers.get('x-forwarded-proto') || 'http';
        const host = headers.get('x-forwarded-host') || headers.get('host');
        const base = `${proto}://${host}`;
        const url = new URL(req.url || '/', base);
        const request = new Request(url.href, {
            method,
            headers,
            // @ts-ignore
            body: method === 'GET' || method === 'HEAD'
                ? undefined
                : node_stream_1.Readable.toWeb(req),
        });
        Promise.resolve()
            .then(() => handler(request))
            .then((response) => {
            res.statusCode = response.status;
            res.statusMessage = response.statusText;
            response.headers.forEach((value, key) => {
                res.setHeader(key, value);
            });
            if (response.body) {
                return writeReadableStreamToWritable(response.body, res);
            }
            else {
                res.end();
            }
        })
            .catch((err) => {
            console.error(err);
            if (!res.headersSent) {
                res.statusCode = 500;
                res.end('Internal server error\n');
            }
        });
    };
}
exports.default = createFetchServer;
function writeReadableStreamToWritable(stream, writable) {
    return __awaiter(this, void 0, void 0, function* () {
        let reader = stream.getReader();
        function read() {
            return __awaiter(this, void 0, void 0, function* () {
                let { done, value } = yield reader.read();
                if (done) {
                    writable.end();
                    return;
                }
                writable.write(value);
                // If the stream is flushable, flush it to allow streaming to continue.
                let flushable = writable;
                if (typeof flushable.flush === 'function') {
                    flushable.flush();
                }
                yield read();
            });
        }
        try {
            yield read();
        }
        catch (error) {
            writable.destroy(error);
            throw error;
        }
    });
}
//# sourceMappingURL=index.js.map